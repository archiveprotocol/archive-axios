{"mappings":"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","sources":["src/index.ts","src/apAxiosManager.ts","src/apGraphQLManager.ts","src/logger.ts"],"sourcesContent":["export * from './apAxiosManager';\nexport * from './apGraphQLManager';\n","import axios, { AxiosError, AxiosInstance, AxiosResponse } from 'axios';\nimport { InternalAxiosRequestConfig } from 'axios';\nimport { CacheAxiosResponse } from 'axios-cache-interceptor/dist/cache/axios';\nimport axiosRetry from 'axios-retry';\nimport { CreateAxiosDefaults } from 'axios/index';\nimport { KafkaManager } from 'logging-library';\n\nexport interface MyRequestConfig extends InternalAxiosRequestConfig {\n  metadata: {\n    startTime: Date;\n    duration?: number;\n    endTime?: Date;\n  };\n}\n\nexport enum CacheDuration {\n  NO_CACHE,\n  SHORT_CACHE_DURATION,\n}\n\n// Note that only GET requests are cached.\nexport class ApAxiosManager {\n  public cacheToAxiosInstance: Map<CacheDuration, AxiosInstance>;\n  private config?: CreateAxiosDefaults;\n\n  constructor(\n    private blueprintId: string,\n    private kafkaManager: KafkaManager,\n    private requestId?: string,\n  ) {\n    this.cacheToAxiosInstance = new Map();\n  }\n\n  setup(config?: CreateAxiosDefaults): void {\n    this.config = config;\n    this.setupNoCacheDurationInstance();\n  }\n\n  setRequestId(requestId: string): void {\n    this.requestId = requestId;\n  }\n\n  private setupNoCacheDurationInstance() {\n    const shortDurationInstance = axios.create(this.config);\n    axiosRetry(axios, { retries: 2, retryDelay: axiosRetry.exponentialDelay });\n    shortDurationInstance.interceptors.request.use(\n      (config: MyRequestConfig) => this.requestInterceptorOnFulfilled(config),\n      (error: any) => this.requestInterceptorOnRejected(error),\n    );\n\n    shortDurationInstance.interceptors.response.use(\n      (response: AxiosResponse) => this.responseInterceptorOnFulfilled(response),\n      (error: AxiosError) => this.responseInterceptorOnRejected(error),\n    );\n\n    this.cacheToAxiosInstance.set(CacheDuration.NO_CACHE, shortDurationInstance);\n  }\n\n  private async requestInterceptorOnFulfilled(config: MyRequestConfig) {\n    this.assertRequestAllowed(config.url);\n    config.metadata = { startTime: new Date() };\n    return config;\n  }\n\n  private async requestInterceptorOnRejected(error: any) {\n    this.assertRequestAllowed(error.url);\n    return Promise.reject(error);\n  }\n\n  private async responseInterceptorOnFulfilled(response: AxiosResponse) {\n    this.calculateRequestDuration(response.config as MyRequestConfig);\n    if (!(response as CacheAxiosResponse).cached) {\n      await this.logResponseTime(response.config as MyRequestConfig, response.status);\n    }\n    return response;\n  }\n\n  private async responseInterceptorOnRejected(error: AxiosError): Promise<never> {\n    this.calculateRequestDuration(error.config as MyRequestConfig);\n    const status = error.response?.status ?? 400;\n    await this.logResponseTime(error.config as MyRequestConfig, status);\n    await this.kafkaManager.sendLogs([\n      {\n        logLevel: 'error',\n        message: this.generateAxiosErrorMessage(error),\n        timestamp: Date.now(),\n        blueprintId: this.blueprintId,\n        extras: { requestId: this.requestId },\n      },\n    ]);\n    return Promise.reject(error);\n  }\n\n  private async logResponseTime(config: MyRequestConfig, status: number) {\n    await this.kafkaManager.sendResponseTimeToKafka(config, status, this.blueprintId, this.requestId);\n  }\n\n  private calculateRequestDuration(config: MyRequestConfig) {\n    config.metadata.endTime = new Date();\n    config.metadata.duration = config.metadata.endTime.getTime() - config.metadata.startTime.getTime();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  private assertRequestAllowed(_: string) {\n    //Check if request allowed - not implemented yet\n  }\n\n  private generateAxiosErrorMessage(e: AxiosError) {\n    return `Axios Error when calling ${e.config?.method}, url: ${e.request?.url}, params: ${JSON.stringify(\n      e.config?.params,\n    )}, code: ${e.code}, status: ${e.response?.status}, statusText: ${e.response?.statusText}, errorName: ${\n      e.name\n    }, message: ${e.message}, stackTrace: ${e.stack}`;\n  }\n}\n","import { ApAxiosManager, CacheDuration } from './apAxiosManager';\nimport { ArchiveLogger } from './logger';\nimport { AxiosInstance } from 'axios';\n\nexport class ApGraphQLManager {\n  constructor(\n    private axiosManager: ApAxiosManager,\n    private subgraphURL: string,\n  ) {}\n\n  public buildGraphQLRequestVariables(userAddress?: string, fromBlock?: number) {\n    return {\n      ...(fromBlock && { fromBlock: fromBlock }),\n      ...(userAddress && { userAddress: userAddress }),\n    };\n  }\n\n  private selectAxiosInstance(blockNumber?: number): AxiosInstance {\n    if (blockNumber && blockNumber > 0) {\n      return this.axiosManager.cacheToAxiosInstance.get(CacheDuration.SHORT_CACHE_DURATION);\n    }\n    return this.axiosManager.cacheToAxiosInstance.get(CacheDuration.NO_CACHE);\n  }\n\n  /*\n  Function for querying subgraphs.\n  Note that typings are returned in a \"best-effort\" basis, i.e. if the subgraph returns a different type\n  than what was passed when calling the function, this will simply be passed further without errors.\n  Note also that any response with status ~ 2xx will trigger an AxiosError.\n  Suggestion for implementing this function:\n  try {\n    await executeGraphQLQueryOrThrowError<myType>(\"query {uniswapV3Pools { id }}\", 100);\n  }\n  catch (e: any){\n     if (e instanceof AxiosError) {\n      log('axios error', e.message, e.status, e.stack);\n    } else {\n      log('common error', e.stack);\n    }\n  }\n  */\n  async executeGraphQLQueryOrThrowError<T>(payload: string, variables = {}, blockNumber?: number): Promise<T> {\n    const axiosInstance = this.selectAxiosInstance(blockNumber);\n    // Might throw errors if status not like 2xx or if casting to T yields an error.\n    try {\n      const response = await axiosInstance.post<T>(\n        this.subgraphURL,\n        { query: payload, variables: variables },\n        {\n          headers: { 'Content-Type': 'application/json' },\n          timeout: 60000, // Sometimes the subgraph takes a long time to respond than 15 seconds, so we increase the timeout\n        },\n      );\n\n      if ((response.data as any).errors) {\n        const msg = `Invalid response from subgraph ${\n          this.subgraphURL\n        }. payload: ${payload}, variables: ${JSON.stringify(variables)} - ${JSON.stringify(\n          (response.data as any).errors,\n        )}`;\n\n        ArchiveLogger.getLogger().error(msg);\n        throw new Error(msg);\n      }\n      return response.data as T;\n    } catch (e) {\n      const baseMsg = `Error when fetching subgraph ${\n        this.subgraphURL\n      }. payload: ${payload}, variables: ${JSON.stringify(variables)}`;\n      const errorMsg = `code: ${e.code}, status: ${e.response?.status}, statusText: ${e.response\n        ?.statusText}, errorName: ${e.name}, message: ${e.message}, responseError: ${JSON.stringify(\n        e.response?.data?.errors,\n      )}, stackTrace: ${e.stack}`;\n      ArchiveLogger.getLogger().error(baseMsg + errorMsg);\n      throw e;\n    }\n  }\n}\n","import { config } from 'dotenv';\nimport { LoggerManager } from 'logging-library/lib/LoggerManager';\n\nconfig();\n\nexport enum LogLevel {\n  DEBUG = 'debug',\n  ERROR = 'error',\n  INFO = 'info',\n  TRACE = 'trace',\n  WARNING = 'warning',\n}\n\nexport class ArchiveLogger extends LoggerManager {\n  public static getDefaultBlueprintIdentifier(): string {\n    return 'archive-axios-default';\n  }\n}\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}